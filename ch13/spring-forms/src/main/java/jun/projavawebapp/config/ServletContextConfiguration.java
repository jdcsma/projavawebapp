package jun.projavawebapp.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.http.converter.ByteArrayHttpMessageConverter;
import org.springframework.http.converter.FormHttpMessageConverter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.http.converter.xml.MarshallingHttpMessageConverter;
import org.springframework.http.converter.xml.SourceHttpMessageConverter;
import org.springframework.oxm.Marshaller;
import org.springframework.oxm.Unmarshaller;
import org.springframework.stereotype.Controller;
import org.springframework.util.Assert;
import org.springframework.web.servlet.RequestToViewNameTranslator;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.ContentNegotiationConfigurer;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator;
import org.springframework.web.servlet.view.InternalResourceViewResolver;
import org.springframework.web.servlet.view.JstlView;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"jun.projavawebapp.site"},
        useDefaultFilters = false,
        includeFilters = {@ComponentScan.Filter(Controller.class)})
public class ServletContextConfiguration implements WebMvcConfigurer {

    private final static Logger logger = LogManager.getLogger();

    private Marshaller marshaller;
    private Unmarshaller unmarshaller;
    private ObjectMapper mapper;

    // 注意：bean 的名字必须为 viewNameTranslator
    @Bean
    public RequestToViewNameTranslator viewNameTranslator() {
        return logger.traceExit(logger.traceEntry(),
                /**
                 * DefaultRequestToViewNameTranslator
                 *
                 * RequestToViewNameTranslator that simply transforms the URI of
                 * the incoming request into a view name.
                 *
                 * Can be explicitly defined as the viewNameTranslator bean in a
                 * DispatcherServlet context. Otherwise, a plain default instance will be used.
                 *
                 * The default transformation simply strips leading and trailing slashes as well
                 * as the file extension of the URI, and returns the result as the view name with
                 * the configured prefix and a suffix added as appropriate.
                 *
                 * The stripping of the leading slash and file extension can be disabled using
                 * the stripLeadingSlash and stripExtension properties, respectively.
                 *
                 * Find below some examples of request to view name translation.
                 *      http://localhost:8080/gamecast/display.html » display
                 *      http://localhost:8080/gamecast/displayShoppingCart.html » displayShoppingCart
                 *      http://localhost:8080/gamecast/admin/index.html » admin/index
                 */
                new DefaultRequestToViewNameTranslator());
    }

    // 设置 viewResolver 的方式一
    // 注意：bean 的名字必须为 viewResolver
    @Bean
    public ViewResolver viewResolver() {
        logger.traceEntry();
        // InternalResourceViewResolver 用于将视图名称转换成 JSP 文件名。
        /**
         * InternalResourceViewResolver
         *
         * Convenient subclass of UrlBasedViewResolver that supports InternalResourceView (
         * i.e. Servlets and JSPs) and subclasses such as JstlView.
         *
         * The view class for all views generated by this resolver can be specified via
         * UrlBasedViewResolver.setViewClass(java.lang.Class<?>). See UrlBasedViewResolver's
         * javadoc for details. The default is InternalResourceView, or JstlView if the JSTL API is present.
         *
         * BTW, it's good practice to put JSP files that just serve as views under WEB-INF,
         * to hide them from direct access (e.g. via a manually entered URL). Only controllers
         * will be able to access them then.
         *
         * Note: When chaining ViewResolvers, an InternalResourceViewResolver always needs to be last,
         * as it will attempt to resolve any view name, no matter whether the underlying resource actually
         * exists.
         */
        InternalResourceViewResolver resolver =
                new InternalResourceViewResolver();
        resolver.setViewClass(JstlView.class);
        resolver.setPrefix("/WEB-INF/jsp/view/");
        resolver.setSuffix(".jsp");
        return logger.traceExit(resolver);
    }

    // 配置 viewResolver 的方式二
//    @Override
//    public void configureViewResolvers(ViewResolverRegistry registry) {
//        InternalResourceViewResolver resolver =
//                new InternalResourceViewResolver();
//        resolver.setViewClass(JstlView.class);
//        resolver.setPrefix("/WEB-INF/jsp/view/");
//        resolver.setSuffix(".jsp");
//        registry.viewResolver(resolver); // or register.viewResolver(viewResolver());
//    }

    // 配置 viewResolver 的方式三
//    @Override
//    public void configureViewResolvers(ViewResolverRegistry registry) {
//        registry.jsp("WEB-INF/jsp/view/", ".jsp")
//                .viewClass(JstlView.class);
//    }

    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        /**
         * Spring 请求/响应内容协商流程
         *
         * 当请求包含请求实体时，进入消息总是根据请求的 Content-Type 头选择转换器。
         *
         * 当响应包含响应实例时，发送的消息将按照下面的步骤选择转换器：
         *
         * 1）首先，将寻找请求 URL 上的文件扩展名。如果它包含了文件扩展名（例如.html、.xml、.json等），
         * 那么它将根据该扩展名决定被请求的格式。如果它未包含文件扩展名，或者如果文件扩展名不能被识别，
         * 那么它将继续执行下一步。
         *
         * 2）然后，将寻找名为 format 的请求参数（可以配置 format 修改参数名）。如果它存在，那么它将
         * 使用被请求的格式（html、xml、json 等）。如果 format 参数不存在或不被识别，它将继续执行下
         * 一步。
         *
         * 3）最后，将使用 Accept 头确定希望返回的响应格式。
         * 本例中默认的响应格式为 XML（见 defaultContentType(MediaType.APPLICATION_XML)）。
         * 如果客户端请求时 Accept 为 *\\/*，那么服务器将按 XML 格式返回响应实体。
         */

        configurer
                /**
                 * Whether the path extension in the URL path should be used to determine
                 * the requested media type.
                 *
                 * By default this is set to true in which case a request for /hotels.pdf will be
                 * interpreted as a request for "application/pdf" regardless of the 'Accept' header.
                 */
                .favorPathExtension(true)
                /**
                 * Whether a request parameter ("format" by default) should be used to determine
                 * the requested media type. For this option to work you must register media type mappings.
                 *
                 * By default this is set to false.
                 */
                .favorParameter(false)
                /**
                 * Set the query parameter name to use when favorParameter(boolean) is on.
                 *
                 * The default parameter name is "format".
                 */
                .parameterName("mediaType")
                /**
                 * Whether to disable checking the 'Accept' request header.
                 *
                 * By default this value is set to false.
                 */
                .ignoreAcceptHeader(false)
                /**
                 * Deprecated. as of 5.0, in favor of useRegisteredExtensionsOnly(boolean)
                 * which has reverse behavior When favorPathExtension(boolean) is set, this
                 * property determines whether to allow use of JAF (Java Activation Framework)
                 * to resolve a path extension to a specific MediaType.
                 */
                .useJaf(false)
                /**
                 * Set the default content type(s) to use when no content type is requested
                 * in order of priority.
                 *
                 * If destinations are present that do not support any of the given media types,
                 * consider appending MediaType.ALL at the end.
                 *
                 * By default this is not set.
                 */
                .defaultContentType(MediaType.APPLICATION_XML)
                /**
                 * Add a mapping from a key, extracted from a path extension or a query parameter,
                 * to a MediaType. This is required in order for the parameter strategy to work.
                 *
                 * Any extensions explicitly registered here are also whitelisted for the purpose of
                 * Reflected File Download attack detection (see Spring Framework reference documentation
                 * for more details on RFD attack protection).
                 *
                 * The path extension strategy will also try to use ServletContext.getMimeType(java.lang.String)
                 * and MediaTypeFactory to resolve path extensions. To change this behavior see the
                 * useRegisteredExtensionsOnly(boolean) property.
                 */
                .mediaType("xml", MediaType.APPLICATION_XML)
                .mediaType("json", MediaType.APPLICATION_JSON);
    }

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {

        Assert.notNull(marshaller, "The marshaller is null.");
        Assert.notNull(unmarshaller, "This unmarshaller is null.");
        Assert.notNull(mapper, "This mapper is null.");

        /**
         * Implementation of HttpMessageConverter that can read and write byte arrays.
         *
         * By default, this converter supports all media types (*\\/*), and writes
         * with a Content - Type of application/octet - stream. This can be overridden by
         * setting the supportedMediaTypes property.
         */
        converters.add(new ByteArrayHttpMessageConverter());

        /**
         * Implementation of HttpMessageConverter that can read and write strings.
         * By default, this converter supports all media types (*\\/*), and writes
         * with a Content - Type of text/plain. This can be overridden by setting
         * the supportedMediaTypes property.
         */
        converters.add(new StringHttpMessageConverter());

        /**
         * Implementation of HttpMessageConverter to read and write 'normal' HTML forms
         * and also to write (but not read) multipart data (e.g. file uploads).
         *
         * In other words, this converter can read and write the "application/x-www-form-urlencoded"
         * media type as MultiValueMap<String, String>, and it can also write (but not read)
         * the "multipart/form-data" and "multipart/mixed" media types as MultiValueMap<String, Object>.
         */
        converters.add(new FormHttpMessageConverter());

        /**
         * Implementation of HttpMessageConverter that can read and write Source objects.
         */
        converters.add(new SourceHttpMessageConverter<>());

        /**
         * Implementation of HttpMessageConverter that can read and write XML using Spring's
         * Marshaller and Unmarshaller abstractions.
         *
         * This converter requires a Marshaller and Unmarshaller before it can be used.
         * These can be injected by the constructor or bean properties.
         *
         * By default, this converter supports text/xml and application/xml.
         * This can be overridden by setting the supportedMediaTypes property.
         */
        MarshallingHttpMessageConverter xmlConverter =
                new MarshallingHttpMessageConverter();
        xmlConverter.setSupportedMediaTypes(Arrays.asList(
                new MediaType("application", "xml"), // Supported media type
                new MediaType("text", "xml") // Supported media type
        ));
        xmlConverter.setMarshaller(marshaller); // Inject implementation.
        xmlConverter.setUnmarshaller(unmarshaller); // Inject implementation.
        converters.add(xmlConverter);

        /**
         * Implementation of HttpMessageConverter that can read and write JSON using
         * Jackson 2.x's  ObjectMapper.
         *
         * This converter can be used to bind to typed beans, or untyped HashMap instances.
         *
         * By default, this converter supports application/json and application/*+json with
         * UTF-8 character set. This can be overridden by setting the supportedMediaTypes property.
         * The default constructor uses the default configuration provided by Jackson2ObjectMapperBuilder.
         */
        MappingJackson2HttpMessageConverter jsonConverter =
                new MappingJackson2HttpMessageConverter();
        jsonConverter.setSupportedMediaTypes(Arrays.asList(
                new MediaType("application", "json"), // Supported media type
                new MediaType("text", "json") // Supported media type
        ));
        jsonConverter.setObjectMapper(mapper);
        converters.add(jsonConverter);
    }

    @Override
    public void configureDefaultServletHandling(
            DefaultServletHandlerConfigurer configurer) {
        /**
         * Enable forwarding to the "default" Servlet.
         *
         * When this method is used the DefaultServletHttpRequestHandler will try
         * to autodetect the "default" Servlet name. Alternatively, you can specify
         * the name of the default Servlet via enable(String).
         *
         * The ServletContextConfiguration enables Spring MVC with @EnableWebMvc
         * and configures the DefaultServlet with DefaultServletHandlerConfigurer's
         * enable() method.
         */
        configurer.enable();
    }

    @Inject
    public void setMarshaller(Marshaller marshaller) {
        logger.traceEntry("{}", marshaller);
        this.marshaller = marshaller;
        logger.traceExit();
    }

    @Inject
    public void setUnmarshaller(Unmarshaller unmarshaller) {
        logger.traceEntry("{}", unmarshaller);
        this.unmarshaller = unmarshaller;
        logger.traceExit();
    }

    @Inject
    public void setMapper(ObjectMapper mapper) {
        logger.traceEntry("{}", mapper);
        this.mapper = mapper;
        logger.traceExit();
    }
}
